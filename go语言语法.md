本文是go语言语法的介绍。

# 泛型

##### 技术本质：

这是 Go 泛型编程中的一种特殊接口写法（Go 1.18+ 引入），使用 `|` 表示联合类型，不是传统意义上的方法集合接口。

##### 实际用途说明:

###### 1. 泛型函数约束

```go
type Integer interface {
	int | int8 | int16 | int32 | int64
}

func Double[T Integer](v T) T {
    return v * 2
}
```

* 允许编写通用整数处理函数
* 同时保持类型安全（不能传字符串/浮点数）

###### 2. 类型过滤器

确保只能使用特定整数类型：

```go
func PrintSize[T Integer](v T) {
    fmt.Printf("Type: %T\n", v)
}
```

* 合法调用：`PrintSize(42)` 或 `PrintSize(int32(42))`
* 非法调用：`PrintSize(3.14)`（会报错）

###### 3. 性能优化

允许根据整数大小选择最佳实现：

```go
func FastAdd[T Integer](a, b T) T {
    if unsafe.Sizeof(a) <= 4 {
        // 32位及以下整数优化
    } else {
        // 64位整数优化
    }
    return a + b
}
```

##### 对比传统做法

###### 没有泛型时

需要为每个类型重复编写函数：

```go
func AddInt(a, b int) int { return a + b }
func AddInt32(a, b int32) int32 { return a + b }
// ...重复6次
```

###### 使用泛型后

只需一次定义即可支持所有整数类型：

```go
func Add[T Integer](a, b T) T {
    return a + b
}
```

##### 常见疑问解答

###### 为什么需要包含所有这些类型？

不同场景需要不同精度：

* `int8`：节省内存（如图像处理）
* `int64`：金融计算（避免溢出）
* `int`：通用场景（自动匹配平台最优）

###### 为什么不用 `any`？

使用 `any` 会失去类型安全：

```go
func BadDouble(v any) any {
    // 必须使用类型断言，容易出错
    return v.(int) * 2
}
```

# 数组和切片的区别

在 Go 语言中，**数组（Array）** 和 **切片（Slice）** 是两种不同的数据结构，它们的核心区别如下：

---

### 1. **定义与声明**
| 特性         | 数组（Array）                          | 切片（Slice）                          |
|--------------|----------------------------------------|----------------------------------------|
| **声明方式** | 需要指定固定长度，例如 `[5]int`        | 不需要指定长度，例如 `[]int`           |
| **示例**     | `var arr [3]int = [3]int{1, 2, 3}`     | `var slice []int = []int{1, 2, 3}`     |

---

### 2. **容量与动态性**
| 特性               | 数组（Array）                          | 切片（Slice）                          |
|--------------------|----------------------------------------|----------------------------------------|
| **容量固定性**     | 固定大小，无法扩容                     | 动态大小，可自动扩容                   |
| **扩容机制**       | 无（容量不可变）                       | 通过 `append()` 自动扩容（通常扩容为原容量的 2 倍） |
| **底层结构**       | 直接存储数据                           | 引用底层数组，包含 `len`（长度）和 `cap`（容量） |

---

### 3. **传递行为**
| 特性               | 数组（Array）                          | 切片（Slice）                          |
|--------------------|----------------------------------------|----------------------------------------|
| **传递类型**       | 值传递（拷贝整个数组）                 | 引用传递（共享底层数组）                |
| **修改影响**       | 函数内修改不会影响原数组               | 函数内修改会影响原数组（因为共享底层数组） |

---

### 4. **灵活性**
| 特性               | 数组（Array）                          | 切片（Slice）                          |
|--------------------|----------------------------------------|----------------------------------------|
| **切片操作**       | 不支持切片操作（如 `arr[1:3]`）        | 支持切片操作                           |
| **适用场景**       | 数据量固定且需要高性能的场景           | 动态数据集合、需要频繁扩容的场景       |

---

### 5. **性能与内存**
| 特性               | 数组（Array）                          | 切片（Slice）                          |
|--------------------|----------------------------------------|----------------------------------------|
| **内存占用**       | 固定内存，适合小数据集                 | 动态内存，适合大数据集                 |
| **扩容开销**       | 无（容量不可变）                       | 扩容时需要分配新内存并复制数据         |

---

### 6. **比较操作**
| 特性               | 数组（Array）                          | 切片（Slice）                          |
|--------------------|----------------------------------------|----------------------------------------|
| **直接比较**       | 支持 `==` 比较（逐个元素比较）         | 不支持 `==` 比较（需手动遍历元素）     |

---

### 7. **典型使用场景**
- **数组（Array）**：
  - 数据量固定且较小（如颜色 RGB 值 `[3]byte`）。
  - 需要精确控制内存布局的场景（如硬件交互）。
- **切片（Slice）**：
  - 动态数据集合（如从文件或网络读取的不定长数据）。
  - 需要频繁增删元素的场景（如日志处理、数据流）。

---

### 示例对比
```go
// 数组：固定大小
var arr [3]int = [3]int{1, 2, 3}
arr[0] = 10 // 修改元素
fmt.Println(arr) // 输出: [10 2 3]

// 切片：动态扩容
var slice []int = []int{1, 2, 3}
slice = append(slice, 4) // 扩容
fmt.Println(slice) // 输出: [1 2 3 4]
```

---

### 总结建议
- **优先使用切片**：除非需要固定大小的集合，否则切片因其灵活性和动态性更常用。
- **数组的适用场景**：仅在需要严格控制内存或数据量固定时使用数组（如哈希计算中的固定长度输入）。